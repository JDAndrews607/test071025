%%writefile atomClasses.cpp

#include <iostream>
#include <vector>
#include <fstream>
#include <sstream>
#include <string>
#include <cmath>
#include <random>
#include <iomanip>  //allows for use of setprecision() function

using namespace std;

const double meterToAngstrom = 1e10;
const double angstromToMeter = 1e-10;
const double meterToNanometer = 1e9;
const double nanometerToMeter = 1e-9;
const double angstromToNanometer = 1e-1;
const double protonMass = 1.67*1e-27; //kg
const double kB = 1.380649e-23; //Botzman constant J/K
const double bohrRadius = 5.29*1e-11 * meterToAngstrom; //Bohr radius in angstroms
const double eulerConstant = 2.718281828459045; //Euler's constant
const double coulombConstant = 8.9875517923e9 / (meterToAngstrom * meterToAngstrom);  //Coulomb's constant to use in coulombic force calculations
const double electronChargeValue = 1.602176634e-19; //charge of a single proton (+) or electron (-)
const double avogadrosNumber = 6.02214076e23; //avogadro's number
const double pi = 3.14159265358979323846;

static random_device rd; //generates random seed
static mt19937 gen(rd()); //Mersenne Twister random number

/*
Defining functions and classes:
*/
//classes
class Atom;
class Bond;
class BoundaryBox;
//helper functions
double calculateDistance(const Atom& atom1, const Atom& atom2);
vector<double> coordinateOperations(const Atom& atom1, const Atom& atom2, char operation);
vector<double> scalarOperations(vector<double> vec, double& scalar, char operation);
double dotProduct(const vector<double>& vec1, const vector<double>& vec2);
vector<double> crossProduct(const vector<double>& vec1, const vector<double>& vec2);
double vectorMagnitude(const vector<double>& vec);
vector<double> normalizeVector(const vector<double>& vec);
void atomCollisions(Atom& atom1, Atom& atom2);
//MD related functions
void runMD(vector<Atom>& atoms, BoundaryBox& BoundaryBox);
void calculateForcesMD(vector<Atom>& atoms);
void calculateAccelerationsMD(vector<Atom>& atoms, double thermostatVar = 0.0);
void updateVelocitiesMD(vector<Atom>& atoms, float stepSize, double dt, float temp);
void updatePositionsMD(vector<Atom>& atoms, BoundaryBox& BoundaryBox, double dt);

/*
Classes
*/

class Atom {
  public:
    Atom(string species, double x, double y, double z) {
      element = species;
      coordinates = {x, y, z};
      getProperties(species);
    }

//update with vdW radii for each atom and incorporate into distance calculations
    void getProperties(const string& species) {
      bool found = false;
      //Organics
      if (species == "H") {
        charge = 1;
        mass = 1.00794  / avogadrosNumber;
        electronCount = 1;
        vdWRadius = 1.20 * angstromToMeter;
        found = true;
      }
      if (species == "C") {
        charge = 4;
        mass = 12.0107 / avogadrosNumber;
        electronCount = 6;
        vdWRadius = 1.70 * angstromToMeter;
        found = true;
      }
      if (species == "N") {
        charge = -3;
        mass = 14.0067 / avogadrosNumber;
        electronCount = 7;
        vdWRadius = 1.55 * angstromToMeter;
        found = true;
      }
      if (species == "O") {
        charge = -2;
        mass = 15.9994 / avogadrosNumber;
        electronCount = 8;
        vdWRadius = 1.52 * angstromToMeter;
        found = true;
      }
      //Glass
      if (species == "Si") {
        charge = 4;
        mass = 28.0855 / avogadrosNumber;
        electronCount = 14;
        vdWRadius = 2.10 * angstromToMeter;
        found = true;
      }
      //Cations
      if (species == "Li") {
        charge = 1;
        mass = 6.94 / avogadrosNumber;
        electronCount = 3;
        vdWRadius = 1.82 * angstromToMeter;
        found = true;
      }
      if (species == "Na") {
        charge = 1;
        mass = 22.9898 / avogadrosNumber;
        electronCount = 11;
        vdWRadius = 2.27 * angstromToMeter;
        found = true;
      }
      if (species == "K") {
        charge = 1;
        mass = 39.0983 / avogadrosNumber;
        electronCount = 19;
        vdWRadius = 2.75 * angstromToMeter;
        found = true;
      }
      if (species == "Ca") {
        charge = 2;
        mass = 40.078 / avogadrosNumber;
        electronCount = 20;
        vdWRadius = 2.31 * angstromToMeter;
        found = true;
      }
      if (species == "Mg") {
        charge = 2;
        mass = 24.305 / avogadrosNumber;
        electronCount = 12;
        vdWRadius = 1.73 * angstromToMeter;
        found = true;
      }
      //Anions
      if (species == "PO4") {
        charge = -3;
        mass = 30.9738 / avogadrosNumber;
        electronCount = 16;
        vdWRadius = 2.75 * angstromToMeter; //need to find accurate lit source
        found = true;
      }
      if (species == "SO4") {
        charge = -2;
        mass = 32.065 / avogadrosNumber;
        electronCount = 16;
        vdWRadius = 2.80 * angstromToMeter;
        found = true;
      }
      if (species == "F") {
        charge = -1;
        mass = 18.9984 / avogadrosNumber;
        electronCount = 9;
        vdWRadius = 1.47 * angstromToMeter;
        found = true;
      }
      if (species == "Cl") {
        charge = -1;
        mass = 35.453 / avogadrosNumber;
        electronCount = 17;
        vdWRadius = 1.75 * angstromToMeter;
        found = true;
      }
      if (species == "Br") {
        charge = -1;
        mass = 79.904 / avogadrosNumber;
        electronCount = 35;
        vdWRadius = 1.85 * angstromToMeter;
        found = true;
      }
      if (species == "I") {
        charge = -1;
        mass = 126.904 / avogadrosNumber;
        electronCount = 53;
        vdWRadius = 1.98 * angstromToMeter;
        found = true;
      }
      if (found == false) {
        cout << "Error: Species " << species << " not compatable with current program" << endl;
        exit(1);
      }
    }


  void atomIdentify() {
    cout << this->element;
    for (int i = 0; i < 3; i++) {
      cout << " " << coordinates[i];
    }
    cout << endl;
  }

  string getElement() const { return element; }
  int getCharge() const { return charge; }
  double getMass() const { return mass; }
  int getElectronCount() const { return electronCount; }
  double getVdWRadius() const { return vdWRadius; }

  void moveAtom(double dx, double dy, double dz) {
    coordinates[0] += dx;
    coordinates[1] += dy;
    coordinates[2] += dz;
  }


    vector<double> coordinates = {0, 0, 0};
    vector<double> velocity = {0, 0, 0};
    vector<double> acceleration = {0, 0, 0};
    vector<double> force = {0, 0, 0};

  private:
    string element;
    int charge;
    double mass;
    int electronCount;
    double vdWRadius;

};



class Bond {
  public:
    Bond(Atom atom1, Atom atom2) {
    }

    Bond(Atom atom1, Atom atom2, Atom atom3) {

    }

    Bond(Atom atom1, Atom atom2, Atom atom3, Atom atom4) {

    }

  private:

    double bondEnergy(const Atom& atom1, const Atom& atom2) {
      double distance = calculateDistance(atom1, atom2);
      double bondEnergy = 0.5 * springConstant * pow((distance - equilibriumDistance), 2);
      return bondEnergy;
    }

    double angle(const Atom& atom1, const Atom& atom2, const Atom& atom3) {
      //computing vectors between atoms 1 and 2, and 2 and 3, with atom 2 at the center
      vector<double> vector12 = coordinateOperations(atom2, atom1, '-');
      vector<double> vector23 = coordinateOperations(atom3, atom2, '-');
      //taking dot product of vectors
      double dotProd = dotProduct(vector12, vector23);
      //finding magnitude of vectors
      double magnitude12 = vectorMagnitude(vector12);
      double magnitude23 = vectorMagnitude(vector23);
      //calculating angle between bonds
      double cosTheta = min(1.0, max(-1.0, dotProd / (magnitude12 * magnitude23)));  //to prevent overflow from float precision
      double angle = acos(cosTheta);
      return angle;
    }

    double dihedral(const Atom& atom1, const Atom& atom2, const Atom& atom3, const Atom& atom4) {
      //computing vectors between connected atoms
      vector<double> vector12 = coordinateOperations(atom2, atom1, '-');
      vector<double> vector23 = coordinateOperations(atom3, atom2, '-');
      vector<double> vector34 = coordinateOperations(atom4, atom3, '-');
      //cross product of vectors
      vector<double> cross123 = crossProduct(vector12, vector23);
      vector<double> cross234 = crossProduct(vector23, vector34);
      //checking for zero vectors prior to normalizing
      if (vectorMagnitude(cross123) == 0 || vectorMagnitude(cross234) == 0) {
        throw invalid_argument("Atoms are colinear. Cannot compute dihedral");
      }
      //normalizing cross product of vectors
      vector<double> normed123 = normalizeVector(cross123);
      vector<double> normed234 = normalizeVector(cross234);
      //arguments for arctan
      vector<double> angleRef = crossProduct(normed123, vector23);  //to determine sign
      double x_arg = dotProduct(normed123, normed234);
      double y_arg = dotProduct(angleRef, normed234);
      //computing angle
      return atan2(y_arg, x_arg);
    }



  //these will need to be changed. Only for testing purposes
  float springConstant = 1;
  float equilibriumAngle = 106.5;
  float equilibriumDistance = 1.56 * meterToAngstrom;


};


class BoundaryBox {
  public:
    BoundaryBox(string ingredients) {
      //testBox();
      //glassFormBox();
      atomDefinedBox(1000, ingredients);
      this->boxVolume = (xHigh - xLow) * (yHigh - yLow) * (zHigh - zLow);
    }

    float getNumberOfAtoms() {
      return numberOfAtoms;
    }

    vector<Atom> fillBox(string ingredients) {  //pass ingredients as (species proportion), ex: (Si 0.33 O 0.66 Li 1)
      vector<Atom> atoms;
      //parsing ingredients
      vector<string> ingredientHold;
      stringstream ss(ingredients);
      string token;
      while (getline(ss, token, ' ')) {
        if (!token.empty()) {
          ingredientHold.push_back(token);
        }
      }
      //placing species and proportions in vectors
      vector<string> species;
      vector<float> proportions;
      for (int i = 0; i < ingredientHold.size(); i++) {
        if (i%2 == 0) {
          cout << ingredientHold[i] << " : " << ingredientHold[i+1] << endl;
          species.push_back(ingredientHold[i]);
          proportions.push_back(stof(ingredientHold[i+1]));
        }
      }
      float proportionSum = 0;
      for (int i = 0; i < proportions.size(); i++) {
        proportionSum += proportions[i];
      }
      for (int j = 0; j < proportions.size(); j++) {  //normalizes proportion vector
        proportions[j] /= proportionSum;
      }
      if (species.empty()) {
        return atoms;
      }

      int numberOfAtoms = 0;
      double averageAtomVolume = 0;
      for (int i = 0; i < proportions.size(); i++) {
        Atom tempAtom = Atom(species[i], 0, 0, 0);
        averageAtomVolume +=  4.0/3.0 * pi * tempAtom.getVdWRadius() * tempAtom.getVdWRadius() * tempAtom.getVdWRadius() * proportions[i];
      }
      numberOfAtoms = this->boxVolume / averageAtomVolume;
      numberOfAtoms = ceil(0.6 * numberOfAtoms); //only take 60% to simulate amorphous close packing environment
      cout << numberOfAtoms << " atoms should be placed" << endl;
      cout << "Number of atoms: " << numberOfAtoms << endl;

      for (int i = 0; i < species.size(); i++) {
        int atomNum = static_cast<int>(numberOfAtoms * proportions[i] + 0.5); //round to nearest integer
        int j = 0;
        int placeAttempts = 0;
        while (j < atomNum && placeAttempts < 100000) {  //placement attempts
          //atom placement loop begins
          bool overlap = false;
          Atom atom = Atom(species[i], randomCoordinate(xLow, xHigh), randomCoordinate(yLow, yHigh), randomCoordinate(zLow, zHigh));
          for (int k = 0; k < atoms.size(); k++) {
            float distance = calculateDistance(atom, atoms[k]);
            double vdWOverlap = atom.getVdWRadius() + atoms[k].getVdWRadius();
            if (distance < 1.00 * vdWOverlap) {  //Checking if the new atom will overlap with old, places far enough away to not triggere large forces
              overlap = true;
              if(atoms.size() > 0) {
                shuffleAtoms(atoms); //randomly moves atoms in box to free up space
              }
              break;
            }
          }
          if(overlap == false) {    //if atom is not overlapping with other atoms it is placed in the vector
            atoms.push_back(atom);
            j++;
            placeAttempts = 0;
          }
          //atom placement loop ends
          placeAttempts++;
        }
      }
    cout << atoms.size() << " atoms placed in box" << endl;
    return atoms;
    }

    void checkCollision(Atom& atom) {
      double distanceBeyond;
      //checking collision on x-axis
      if (atom.coordinates[0] > xHigh || atom.coordinates[0] < xLow) {
        if (atom.coordinates[0] > xHigh) {
          distanceBeyond = atom.coordinates[0] - xHigh;
          atom.coordinates[0] = xHigh - distanceBeyond;
          atom.velocity[0] = -atom.velocity[0];
        }
        else if (atom.coordinates[0] < xLow) {
          distanceBeyond = xLow - atom.coordinates[0];
          atom.coordinates[0] = xLow + distanceBeyond;
          atom.velocity[0] = -atom.velocity[0];
        }
      }
      //checking collision on y-axis
      if (atom.coordinates[1] > yHigh || atom.coordinates[1] < yLow) {
        if (atom.coordinates[1] > yHigh) {
          distanceBeyond = atom.coordinates[1] - yHigh;
          atom.coordinates[1] = yHigh - distanceBeyond;
          atom.velocity[1] = -atom.velocity[1];
        }
        else if (atom.coordinates[1] < yLow) {
          distanceBeyond = yLow - atom.coordinates[1];
          atom.coordinates[1] = yLow + distanceBeyond;
          atom.velocity[1] = -atom.velocity[1];
        }
      }
      //checking collision on z-axis
      if (atom.coordinates[2] > zHigh || atom.coordinates[2] < zLow) {
        if (atom.coordinates[2] > zHigh) {
          distanceBeyond = atom.coordinates[2] - zHigh;
          atom.coordinates[2] = zHigh - distanceBeyond;
          atom.velocity[2] = -atom.velocity[2];
        }
        else if (atom.coordinates[2] < zLow) {
          distanceBeyond = zLow - atom.coordinates[2];
          atom.coordinates[2] = zLow + distanceBeyond;
          atom.velocity[2] = -atom.velocity[2];
        }
      }
    }


    void initialVelocities(vector<Atom>& atoms, double temp) {
      //Using Maxwell-Boltzman Distribution
      //Initializing velocities
      for (int i = 0; i < atoms.size(); i++) {
        double sigma = sqrt(kB * temp / atoms[i].getMass()) * meterToAngstrom;  //converts meters to angstroms
        //atoms[i].velocity = {randomCoordinate(xLow, xHigh), randomCoordinate(yLow, yHigh), randomCoordinate(zLow, zHigh)};
        //atoms[i].velocity = scalarOperations(atoms[i].velocity, sigma, '*');
        normal_distribution<> dis(0, sigma);
        atoms[i].velocity = {dis(gen), dis(gen), dis(gen)};
      }
      //Accounting for center of mass velocities
      double massTotal = 0;
      vector<double> momentumTotal = {0, 0, 0};
      for (int i = 0; i < atoms.size(); i++) {
        massTotal += atoms[i].getMass();
        for (int j = 0; j < 3; j++) {
          momentumTotal[j] += atoms[i].getMass() * atoms[i].velocity[j];
        }
      }
      for (int i = 0; i < atoms.size(); i++) {
        for (int j = 0; j < 3; j++) {
        atoms[i].velocity[j] -= (momentumTotal[j] / massTotal);
        }
      }
    }

  vector<double> getBoxBoundaries() {
    vector<double> boxBoundaries = {xLow, xHigh, yLow, yHigh, zLow, zHigh};
    return boxBoundaries;
  }

  private:

  void shuffleAtoms(vector<Atom>& atoms) {
    int i = 0;
    while(i < atoms.size()) {
      atoms[i].coordinates[0] = randomCoordinate(xLow, xHigh);
      atoms[i].coordinates[1] = randomCoordinate(yLow, yHigh);
      atoms[i].coordinates[2] = randomCoordinate(zLow, zHigh);
      for(int j = 0; j < atoms.size(); j++) {
        if (i != j) {
          double distance = calculateDistance(atoms[i], atoms[j]);
          if(distance >= atoms[i].getVdWRadius() + atoms[j].getVdWRadius()) {
            i++;
          }
        }
      }
    }
  }

    double randomCoordinate(double low, double high) {
      uniform_real_distribution<> dis(low, high); //generates value between low and high
      return dis(gen);
    }


    void glassFormBox() { //set currently at nanometers
      xLow = 0.0 * nanometerToMeter;
      xHigh = 25.0 * nanometerToMeter;
      yLow = 0.0 * nanometerToMeter;
      yHigh = 25.0 * nanometerToMeter;
      zLow = 0.0 * nanometerToMeter;
      zHigh = 12.5 * nanometerToMeter;
    }

    void testBox() {
      xLow = 0.0 * nanometerToMeter;
      xHigh = 1.0 * nanometerToMeter;
      yLow = 0.0 * nanometerToMeter;
      yHigh = 1.0 * nanometerToMeter;
      zLow = 0.0 * nanometerToMeter;
      zHigh = 1.0 * nanometerToMeter;
    }

    void atomDefinedBox(int atomNum, string ingredients) {
      //parsing ingredients
      vector<string> ingredientHold;
      stringstream ss(ingredients);
      string token;
      while (getline(ss, token, ' ')) {
        if (!token.empty()) {
          ingredientHold.push_back(token);
        }
      }
      //placing species and proportions in vectors
      vector<string> species;
      vector<float> proportions;
      for (int i = 0; i < ingredientHold.size(); i++) {
        if (i%2 == 0) {
          cout << ingredientHold[i] << " : " << ingredientHold[i+1] << endl;
          species.push_back(ingredientHold[i]);
          proportions.push_back(stof(ingredientHold[i+1]));
        }
      }
      float proportionSum = 0;
      for (int i = 0; i < proportions.size(); i++) {
        proportionSum += proportions[i];
      }
      for (int j = 0; j < proportions.size(); j++) {  //normalizes proportion vector
        proportions[j] /= proportionSum;
      }
      //calculating volumes from atom proportions
      double avgAtomVolume = 0;
      double atomVolume = 0;
      for(int n = 0; n < species.size(); n++) {
        Atom testAtom(species[n], 0, 0, 0);
        atomVolume = 4.0/3.0 * pi * pow(testAtom.getVdWRadius() * angstromToMeter, 3);
        avgAtomVolume += atomVolume * proportions[n];
      }

      double boxVolume = atomNum * avgAtomVolume;
      double boxSide = cbrt(boxVolume) * meterToAngstrom;
      xHigh = boxSide;
      xLow = 0;
      yHigh = boxSide;
      yLow = 0;
      zHigh = boxSide;
      zLow = 0;
      cout << "Number of atoms requested: " << atomNum << endl;
      cout << "Box dimensions: " << xLow << " " << xHigh << " " << yLow << " " << yHigh << " " << zLow << " " << zHigh << endl;
    }


    double xLow;
    double xHigh;
    double yLow;
    double yHigh;
    double zLow;
    double zHigh;
    float boxVolume;
    int numberOfAtoms;
};


/*
Helper Functions
*/


double calculateDistance(const Atom& atom1, const Atom& atom2) {
  double distanceX = pow((atom1.coordinates[0] - atom2.coordinates[0]), 2);
  double distanceY = pow((atom1.coordinates[1] - atom2.coordinates[1]), 2);
  double distanceZ = pow((atom1.coordinates[2] - atom2.coordinates[2]), 2);
  double distanceAll = distanceX + distanceY + distanceZ;
  double distance = sqrt(distanceAll);
  return distance;
}

vector<double> coordinateOperations(const Atom& atom1, const Atom& atom2, char operation) {
  vector<double> result = {0, 0, 0};
  if (operation == '+') {
    for (int i = 0; i < 3; i++) {
      result[i] = atom1.coordinates[i] + atom2.coordinates[i];
    }
  }
  else if (operation == '-') {
    for (int i = 0; i < 3; i++) {
      result[i] = atom1.coordinates[i] - atom2.coordinates[i];
    }
  }
  else if (operation == '*') {
    for (int i = 0; i < 3; i++) {
      result[i] = atom1.coordinates[i] * atom2.coordinates[i];
    }
  }
  else if (operation == '/') {
    for (int i = 0; i < 3; i++) {
      result[i] = atom1.coordinates[i] / atom2.coordinates[i];
    }
  }
  else {
    throw invalid_argument("Invalid operation");
  }
  return result;
}

vector<double> scalarOperations(vector<double> vec, double& scalar, char operation) {
  vector<double> result = {0, 0, 0};
  if (operation == '+') {
    for (int i = 0; i < 3; i++) {
      result[i] = vec[i] + scalar;
    }
  }
  else if (operation == '-') {
    for (int i = 0; i < 3; i++) {
      result[i] = vec[i] - scalar;
    }
  }
  else if (operation == '*') {
    for (int i = 0; i < 3; i++) {
      result[i] = vec[i] * scalar;
    }
  }
  else if (operation == '/') {
    if (scalar != 0) {
      for (int i = 0; i < 3; i++) {
        result[i] = vec[i] / scalar;
      }
    }
    else {
      throw invalid_argument("Invalid operation. Cannot divide by zero");
    }
  }
  else {
    throw invalid_argument("Invalid operation");
  }
  return result;
}

double dotProduct(const vector<double>& vec1, const vector<double>& vec2) {
  double result;
  result = vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];
  return result;
}

vector<double> crossProduct(const vector<double>& vec1, const vector<double>& vec2) {
  vector<double> result = {0, 0, 0};
  result[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];  //x component
  result[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];  //y component
  result[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];  //z component
  return result;
}

double vectorMagnitude(const vector<double>& vec) {
  if (vec.size() != 3) {
    throw invalid_argument("Invalid vector size, vector must be 3-dimensional");
  }
  double result;
  result = sqrt(dotProduct(vec, vec));
  return result;
}

vector<double> normalizeVector(const vector<double>& vec) {
  if (vec.size() != 3) {
    throw invalid_argument("Invalid vector size, vector must be 3-dimensional");
  }
  vector<double> result = {0, 0, 0};
  double magnitude = vectorMagnitude(vec);
  if (magnitude == 0) {
    throw invalid_argument("Zero vector cannot be normalized");
  }
  for (int i = 0; i < 3; i++) {
    result[i] = vec[i] / magnitude;
  }
  return result;
}

void atomCollisions(Atom& atom1, Atom& atom2) {   //atom1 will always be the atom moving, atom2 the atom that atom1 is coming into contact with
  double distance = calculateDistance(atom1, atom2);
  if (distance <= (atom1.getVdWRadius() + atom2.getVdWRadius())) {  //signifies collision between atoms
    double distX = atom1.coordinates[0] - atom2.coordinates[0];
    double distY = atom1.coordinates[1] - atom2.coordinates[1];
    double distZ = atom1.coordinates[2] - atom2.coordinates[2];
    //finding the collision normals and relative velocities of atoms
    vector<double> collisions = {distX / distance, distY / distance, distZ / distance};
    vector<double> velocities = {atom1.velocity[0] - atom2.velocity[0], atom1.velocity[1] - atom2.velocity[1], atom1.velocity[2] - atom2.velocity[2]};
    //velocity upon impact between atoms
    double impactVelocity = dotProduct(collisions, velocities);
    //updating velocities based on collision
    for (int i = 0; i < 3; i++) {
      double impulse = 2 * atom1.getMass() * atom2.getMass() / (atom1.getMass() + atom2.getMass()) * impactVelocity * collisions[i];
      atom1.velocity[i] -= impulse / atom1.getMass();
      atom2.velocity[i] += impulse / atom2.getMass();
    }
  }
}

vector<double> getBuckinghamParameters(const Atom& atom1, const Atom& atom2) {
  if (atom1.getElement() == "si" && atom2.getElement() == "O" || atom1.getElement() == "O" && atom2.getElement() == "si") {
    return {18003.7572, 0.205204 * meterToAngstrom, 133.5381 * meterToAngstrom};
  }
  else if (atom1.getElement() == "Si" && atom2.getElement() == "Si") {
    return {0, 0, 0};
  }
  else if (atom1.getElement() == "O" && atom2.getElement() == "O") {
    return {1388.773, 0.362319 * meterToAngstrom, 175.0 * meterToAngstrom};
  }
  else {
    return {0, 0, 0};
  }
}


//helper functions for thermostat

double calculateKineticEnergy(vector<Atom>& atoms) {
  double kineticEnergy = 0;
  for (int i = 0; i < atoms.size(); i++) {
    for (int j = 0; j < 3; j++) {
      kineticEnergy += 0.5 * atoms[i].getMass() * pow(atoms[i].velocity[j], 2);
    }
  }
  return kineticEnergy;
}

double measureTemp(vector<Atom>& atoms) {
  int degreesOfFreedom = 3 * atoms.size();  //degrees of freedom without constraints
  double kineticEnergy = calculateKineticEnergy(atoms);
  double temperature = (2.0 * kineticEnergy) / (kB * degreesOfFreedom);
  return temperature;
}

//Molecular Dynamics

//Using the velocity verlet algorithm. default to half-step velocities
void runMD_VelocityHalfStep(vector<Atom>& atoms, BoundaryBox& BoundaryBox, double dt, int iterations = 250, float startTemp = 20, float stopTemp = 2800) {

  startTemp = startTemp + 273.15; //converting to kelvin
  stopTemp = stopTemp + 273.15; //converting to kelvin
  int heaterSteps = 250;
  float currentTemp = startTemp;
  float tempStep = (stopTemp - startTemp) / heaterSteps;

  //preheating steps:
  for(int i = 0; i < heaterSteps; i++) {
    currentTemp += tempStep;
    //reset forces and accelerations
    for (int j = 0; j < atoms.size(); j++) {
      atoms[j].force = {0, 0, 0};
      atoms[j].acceleration = {0, 0, 0};
    }
    calculateForcesMD(atoms);
    calculateAccelerationsMD(atoms);
    updatePositionsMD(atoms, BoundaryBox, dt);
    updateVelocitiesMD(atoms, 1.0, dt, currentTemp);
    //scaling velocities
    double measuredTemp = measureTemp(atoms);
    if(measuredTemp < 1e-6) {
      measuredTemp = 1e-6;
    }
    double scale = sqrt(currentTemp / measuredTemp);
    for (int j = 0; j < atoms.size(); j++) {
      atoms[j].velocity = scalarOperations(atoms[j].velocity, scale, '*');
    }
  }
  double systemTemp = measureTemp(atoms);
  cout << "System Temperature after preheat stage: " << currentTemp << endl;

  //for writing to file
  string fileName = "coordinates.txt";
  ofstream outFile(fileName);   //creates file if not present. Opens if present
  if (!outFile.is_open()) {
    cout << "Error opening file" << endl;
    return;
  }

  //writing initial coordinates to file
  outFile << "Initial Coordinates" << endl;
  outFile << "{" << endl;
  for (int i = 0; i < atoms.size(); i++) {
    outFile << atoms[i].getElement() << " " << atoms[i].coordinates[0]*angstromToMeter << " " << atoms[i].coordinates[1]*angstromToMeter << " " << atoms[i].coordinates[2]*angstromToMeter << endl;
  }
  outFile << "}" << endl;
  outFile << endl;
  outFile << endl;

  cout << "System Temperature after initial velocities: " << systemTemp << endl;

  //constants for Nose-Hoover thermostat
  int degOfFreedom = 3 * atoms.size();
  double timeConstant = 0; //Q, couple with dt
  if(BoundaryBox.getNumberOfAtoms() < 100) {
    timeConstant = 5e-10;
  }
  else if(BoundaryBox.getNumberOfAtoms() < 1000) {
    timeConstant = 5e-11;
  }
  else {
    timeConstant = 5e-12;
  }
  cout << "Time Constant: " << timeConstant << endl;
  double thermMass = degOfFreedom * kB * systemTemp * timeConstant * timeConstant;
  double thermostatVar = 0;

  //updating thermostat

  double kineticEnergy = calculateKineticEnergy(atoms);
  //thermostatVar += (dt / (2.0 * thermMass)) * (2.0 * kineticEnergy - degOfFreedom * kB * systemTemp);

  //writing initial coordinates to file
  outFile << "Coordinates after first kick" << endl;
  outFile << "{" << endl;
  for (int i = 0; i < atoms.size(); i++) {
    outFile << atoms[i].getElement() << " " << atoms[i].coordinates[0]*angstromToMeter << " " << atoms[i].coordinates[1]*angstromToMeter << " " << atoms[i].coordinates[2]*angstromToMeter << endl;
  }
  outFile << "}" << endl;
  outFile << endl;
  outFile << endl;

  int count = 0;
  //velocity verlet loop
  while (count < iterations) {

    //updating locations of atoms from previous iteration
    updatePositionsMD(atoms, BoundaryBox, dt);

    //resetting forces to zero prior to force calculation
    for (int i = 0; i < atoms.size(); i++) {
      for (int j = 0; j < 3; j++) {
        atoms[i].force[j] = 0;
      }
    }
    //calculating forces
    calculateForcesMD(atoms);

    //updating accelerations
    calculateAccelerationsMD(atoms, thermostatVar);

    //updating velocities with half step kick. Set at half step, dt = 0.5
    updateVelocitiesMD(atoms, 0.5, dt, systemTemp);

    //updating thermostat
    if(count > 0) {
      kineticEnergy = calculateKineticEnergy(atoms);
      thermostatVar += (dt / (2.0 * thermMass)) * (2.0 * kineticEnergy - degOfFreedom * kB * systemTemp);
    }

    //updating velocities for half step kick. Set at half step with dt = 0.5
    calculateAccelerationsMD(atoms, thermostatVar);
    updateVelocitiesMD(atoms, 0.5, dt, systemTemp);


    //incrementing for next iteration
    count++;
    cout << "Iteration: " << count << endl;

    //writing coordinates to file
    outFile << "Iteration: " << count << endl;
    outFile << "{" << endl;
    for (int i = 0; i < atoms.size(); i++) {
      outFile << atoms[i].getElement() << " " << atoms[i].coordinates[0]*angstromToMeter << " " << atoms[i].coordinates[1]*angstromToMeter << " " << atoms[i].coordinates[2]*angstromToMeter << endl;
    }
    outFile << "}" << endl;
    outFile << endl;
    outFile << endl;

    cout << atoms[5].coordinates[0] << " " << atoms[5].coordinates[1] << " " << atoms[5].coordinates[2] << endl;
    cout << "Zeta=" << thermostatVar << endl;

    if (count == iterations) {
      cout << "MD complete" << endl;
      outFile.close();
    }
  }
}

double calculateMaxVelocity(double mass, float temp) {
  double maxVelocity = 3.0 * sqrt(3.0 * kB * temp / mass);  //within 3 standard deviations of root ,mean square velocity
  return maxVelocity * meterToAngstrom;
}

void updatePositionsMD(vector<Atom>& atoms, BoundaryBox& BoundaryBox, double dt) {
  for (int i = 0; i < atoms.size(); i++) {
    for (int j = 0; j < 3; j++) {
      atoms[i].coordinates[j] += atoms[i].velocity[j] * dt + 0.5 * atoms[i].acceleration[j] * dt * dt;
    }
    BoundaryBox.checkCollision(atoms[i]);
    for (int k = 0; k < atoms.size(); k++) {
      if (k != i) {
        atomCollisions(atoms[i], atoms[k]);
      }
    }
  }
}


void updateVelocitiesMD(vector<Atom>& atoms, float stepSize, double dt, float temp) {
  for (int i = 0; i < atoms.size(); i++) {
    for (int j = 0; j < 3; j++) {
      atoms[i].velocity[j] += atoms[i].acceleration[j] * dt * stepSize;
    }
    //checking to see if velocity is over max threshold
    double maxVelocity = calculateMaxVelocity(atoms[i].getMass(), temp);
    double calcVelocity = vectorMagnitude(atoms[i].velocity);
    if (calcVelocity > maxVelocity) {
      atoms[i].velocity = scalarOperations(atoms[i].velocity, calcVelocity, '/');
      atoms[i].velocity = scalarOperations(atoms[i].velocity, maxVelocity, '*');
    }
  }
}

void calculateForcesMD(vector<Atom>& atoms) {
  //resetting forces
  for (int i = 0; i < atoms.size(); i++) {
    for (int j = 0; j < 3; j++) {
      atoms[i].force[j] = 0;
    }
  }
  //computing new forces
  for (int i = 0; i < atoms.size(); i++) {
    for (int j = i+1; j < atoms.size(); j++) {
      //calculating coulombic forces
      vector<double> distanceAsVector = coordinateOperations(atoms[i], atoms[j], '-');
      double distance = calculateDistance(atoms[i], atoms[j]);
      if (fabs(distance) < 0.1 * meterToAngstrom) {
        distance = 0.1 * meterToAngstrom;
      }
      double coulombicForce = coulombConstant * (atoms[i].getCharge() * atoms[j].getCharge()) / (distance * distance);
      vector<double> coulombicForceVector = scalarOperations(scalarOperations(distanceAsVector, distance, '/'), coulombicForce, '*');
      //calculating Buckingham forces
      vector<double> buckinghamForce = {0, 0, 0};
      double buckA = 0;
      double buckRho = 0;
      double buckC = 0;
      double buckMagnitude = 0;
      vector<double> normalizedDistance = {0, 0, 0};
      if (distance < 10.0 * meterToAngstrom) {  //buckinham cutoff
        vector<double> buckinghamParameters = getBuckinghamParameters(atoms[i], atoms[j]);
        if (buckinghamParameters[1] != 0) { //prevents division by zero
          buckA = buckinghamParameters[0];
          buckRho = buckinghamParameters[1];
          buckC = buckinghamParameters[2];
          buckMagnitude = (buckA / buckRho) * exp(-distance / buckRho) - 6 * buckC / pow(distance, 7);
          normalizedDistance = normalizeVector(distanceAsVector);
          buckinghamForce = scalarOperations(normalizedDistance, buckMagnitude, '*');
        }
        else {
          for (int k = 0; k < 3; k++) {
            buckinghamForce[k] = 0;
          }
        }
      }
      else {
        for (int k = 0; k < 3; k++) {
          buckinghamForce[k] = 0;
        }
      }
      //totaling and applying forces
      vector<double> totalForceVector(3, 0.0);
      totalForceVector[0] = coulombicForceVector[0] + buckinghamForce[0];
      totalForceVector[1] = coulombicForceVector[1] + buckinghamForce[1];
      totalForceVector[2] = coulombicForceVector[2] + buckinghamForce[2];
      double forceMagnitude = vectorMagnitude(totalForceVector);
      if(forceMagnitude > 1e-9) {
        double scale = 1e-9 / forceMagnitude;
        totalForceVector = scalarOperations(totalForceVector, scale, '*');
      }
      atoms[i].force[0] += totalForceVector[0];
      atoms[i].force[1] += totalForceVector[1];
      atoms[i].force[2] += totalForceVector[2];
      atoms[j].force[0] -= totalForceVector[0];
      atoms[j].force[1] -= totalForceVector[1];
      atoms[j].force[2] -= totalForceVector[2];
    }
  }
}

void calculateAccelerationsMD(vector<Atom>& atoms, double thermostatVar) {
  for (int i = 0; i < atoms.size(); i++) {
    for (int j = 0; j < 3; j++) {
      atoms[i].acceleration[j] = atoms[i].force[j] / atoms[i].getMass() - thermostatVar * atoms[i].velocity[j];
    }
  }
}

void preheatSystem(vector<Atom>& atoms, float startTemp, float endTemp, int heatingSteps) {
  cout << "pass" << endl;
}


int main() {
  cout << scientific;   //sets scientific notation for all numbers
  cout << setprecision(6) << endl;  //will use six decimal places for all numbers

  string ingredients = "Si 0.33 O 0.66 Li 0.01";
  BoundaryBox testBox = BoundaryBox(ingredients);
  vector<Atom> atoms = testBox.fillBox(ingredients);
  runMD_VelocityHalfStep(atoms, testBox, 1e-15, 100);



  return 0;
}
